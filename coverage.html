
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>dsl: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/aprksy/knitknot/pkg/dsl/lexer.go (98.0%)</option>
				
				<option value="file1">github.com/aprksy/knitknot/pkg/dsl/parser.go (96.4%)</option>
				
				<option value="file2">github.com/aprksy/knitknot/pkg/graph/builder.go (87.8%)</option>
				
				<option value="file3">github.com/aprksy/knitknot/pkg/graph/engine.go (30.0%)</option>
				
				<option value="file4">github.com/aprksy/knitknot/pkg/query/default.go (86.6%)</option>
				
				<option value="file5">github.com/aprksy/knitknot/pkg/storage/inmem/inmem.go (87.2%)</option>
				
				<option value="file6">github.com/aprksy/knitknot/pkg/storage/inmem/persist.go (79.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package dsl

type Lexer struct {
        input        string
        position     int  // current position in input (points to char)
        readPosition int  // reading ahead
        ch           byte // current char
}

func NewLexer(input string) *Lexer <span class="cov5" title="16">{
        l := &amp;Lexer{input: input}
        l.readChar()
        // l.readPosition = 0
        // l.ch = l.input[l.readPosition]
        return l
}</span>

func (l *Lexer) readChar() <span class="cov10" title="393">{
        if l.readPosition &gt;= len(l.input) </span><span class="cov5" title="27">{
                l.ch = 0
        }</span> else<span class="cov9" title="366"> {
                l.ch = l.input[l.readPosition]
        }</span>
        <span class="cov10" title="393">l.position = l.readPosition
        l.readPosition++</span>
}

func (l *Lexer) NextToken() Token <span class="cov8" title="130">{
        var tok Token

        l.skipWhitespace()
        position := l.position

        switch l.ch </span>{
        case '.':<span class="cov4" title="10">
                tok = Token{Type: Dot, Literal: ".", PosX: position}</span>
        case '(':<span class="cov5" title="21">
                tok = Token{Type: LParen, Literal: "(", PosX: position}</span>
        case ')':<span class="cov5" title="18">
                tok = Token{Type: RParen, Literal: ")", PosX: position}</span>
        case ',':<span class="cov4" title="11">
                tok = Token{Type: Comma, Literal: ",", PosX: position}</span>
        case '\'':<span class="cov6" title="28">
                str := l.readString()
                tok = Token{Type: String, Literal: str, PosX: position}
                return tok</span> // ← Return early! Already advanced in readString
        case 0:<span class="cov4" title="14">
                tok = Token{Type: EOF, Literal: ""}</span>
        default:<span class="cov6" title="28">
                if isLetter(l.ch) </span><span class="cov5" title="23">{
                        id := l.readIdentifier()
                        tok = Token{Type: Ident, Literal: id, PosX: position}
                        return tok // ← Return early! Already advanced
                }</span> else<span class="cov3" title="5"> if isDigit(l.ch) </span><span class="cov3" title="5">{
                        num := l.readNumber()
                        tok = Token{Type: Number, Literal: num, PosX: position}
                        return tok // ← Return early!
                }</span> else<span class="cov0" title="0"> {
                        tok = Token{Type: Illegal, Literal: string(l.ch), PosX: position}
                }</span>
        }

        // Only advance if we didn't return early
        <span class="cov7" title="74">l.readChar()
        return tok</span>
}

func (l *Lexer) skipWhitespace() <span class="cov8" title="130">{
        for l.ch == ' ' || l.ch == '\t' || l.ch == '\n' || l.ch == '\r' </span><span class="cov5" title="24">{
                l.readChar()
        }</span>
}

func (l *Lexer) readIdentifier() string <span class="cov5" title="23">{
        pos := l.position
        for isLetter(l.ch) || isDigit(l.ch) || l.ch == '_' </span><span class="cov7" title="90">{
                l.readChar()
        }</span>
        <span class="cov5" title="23">return l.input[pos:l.position]</span>
}

func (l *Lexer) readString() string <span class="cov6" title="28">{
        pos := l.position + 1 // start after opening '
        l.readChar()          // consume opening '

        for l.ch != '\'' &amp;&amp; l.ch != 0 </span><span class="cov8" title="125">{
                l.readChar()
        }</span>

        // At this point, l.ch is '\'' or 0
        // Extract string content
        <span class="cov6" title="28">s := l.input[pos:l.position]

        // If we stopped at ', consume it
        if l.ch == '\'' </span><span class="cov5" title="27">{
                l.readChar() // now points after closing '
        }</span>

        <span class="cov6" title="28">return s</span>
}

func (l *Lexer) readNumber() string <span class="cov3" title="5">{
        pos := l.position
        for isDigit(l.ch) </span><span class="cov4" title="9">{
                l.readChar()
        }</span>
        <span class="cov3" title="5">return l.input[pos:l.position]</span>
}

func isLetter(ch byte) bool <span class="cov8" title="141">{
        return 'a' &lt;= ch &amp;&amp; ch &lt;= 'z' || 'A' &lt;= ch &amp;&amp; ch &lt;= 'Z'
}</span>

func isDigit(ch byte) bool <span class="cov6" title="42">{
        return '0' &lt;= ch &amp;&amp; ch &lt;= '9'
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package dsl

import (
        "fmt"
        "strconv"
)

type Parser struct {
        l         *Lexer
        curToken  Token
        peekToken Token
        errors    []string
}

func NewParser(input string) *Parser <span class="cov6" title="16">{
        l := NewLexer(input)
        p := &amp;Parser{l: l}
        p.nextToken()
        p.nextToken()
        return p
}</span>

func (p *Parser) nextToken() <span class="cov10" title="130">{
        p.curToken = p.peekToken
        p.peekToken = p.l.NextToken()
}</span>

func (p *Parser) Parse() (*Query, error) <span class="cov6" title="16">{
        query := &amp;Query{Methods: []*MethodCall{}}

        // fmt.Printf("%s: %s, %s: %s\n", p.curToken.Type, p.curToken.Literal, p.peekToken.Type, p.peekToken.Literal)
        for p.curToken.Type != EOF </span><span class="cov6" title="23">{
                if p.curToken.Type == Ident </span><span class="cov6" title="22">{
                        method := p.parseMethodCall()
                        if method == nil </span><span class="cov3" title="4">{
                                return nil, fmt.Errorf("failed to parse method at pos %d. %s", p.l.position-1, p.errors[0])
                        }</span>
                        <span class="cov6" title="18">query.Methods = append(query.Methods, method)</span>
                } else<span class="cov1" title="1"> {
                        return nil, fmt.Errorf("expected method name, got %v at pos %d", p.curToken.Type, p.curToken.PosX)
                }</span>

                <span class="cov6" title="18">if p.expectPeek(Dot) </span><span class="cov4" title="8">{
                        p.nextToken() // consume dot
                }</span> else<span class="cov5" title="10"> {
                        break</span>
                }
        }

        <span class="cov5" title="11">if p.curToken.Type == EOF </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("expected method name, got %v at pos %d", p.curToken.Type, p.curToken.PosX)
        }</span>

        <span class="cov5" title="10">return query, nil</span>
}

func (p *Parser) parseMethodCall() *MethodCall <span class="cov6" title="22">{
        methodName := &amp;Identifier{Value: p.curToken.Literal}

        if !p.expectPeek(LParen) </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov6" title="21">p.nextToken()

        args := p.parseArguments()
        if args == nil </span><span class="cov3" title="3">{
                return nil
        }</span>

        <span class="cov6" title="18">methodCall := MethodCall{
                Name:      methodName,
                Arguments: args,
        }
        return &amp;methodCall</span>
}

func (p *Parser) parseArguments() []Expression <span class="cov6" title="21">{
        var args []Expression

        if p.curToken.Type != RParen </span><span class="cov6" title="21">{
                args = []Expression{}

                arg := p.parseExpression()
                if arg != nil </span><span class="cov6" title="21">{
                        args = append(args, arg)
                }</span>

                <span class="cov6" title="21">for p.peekToken.Type == Comma </span><span class="cov5" title="11">{
                        p.nextToken()
                        p.nextToken()
                        arg := p.parseExpression()
                        if arg != nil </span><span class="cov5" title="11">{
                                args = append(args, arg)
                        }</span>
                }
        }

        // if p.peekToken.Type == RParen {
        //         p.nextToken()
        //         return args
        // }

        <span class="cov6" title="21">if !p.expectPeek(RParen) </span><span class="cov3" title="3">{
                return nil
        }</span>

        <span class="cov6" title="18">return args</span>
}

func (p *Parser) parseExpression() Expression <span class="cov7" title="32">{
        switch p.curToken.Type </span>{
        case String:<span class="cov7" title="27">
                return &amp;StringLiteral{Value: p.curToken.Literal}</span>
        case Number:<span class="cov3" title="5">
                if v, err := strconv.Atoi(p.curToken.Literal); err == nil </span><span class="cov3" title="5">{
                        return &amp;NumberLiteral{Value: v}
                }</span>
        }
        <span class="cov0" title="0">p.errors = append(p.errors, fmt.Sprintf("unexpected token: %s", p.curToken.Literal))
        return nil</span>
}

func (p *Parser) expectPeek(t TokenType) bool <span class="cov8" title="61">{
        if p.peekToken.Type == t </span><span class="cov8" title="47">{
                p.nextToken() // advances curToken to peekToken
                return true
        }</span>
        <span class="cov5" title="14">p.errors = append(p.errors, fmt.Sprintf("expected %v, got %v", t, p.peekToken.Type))
        return false</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// pkg/graph/builder.go
package graph

import (
        "context"
        "fmt"

        "github.com/aprksy/knitknot/pkg/ports/query"
        "github.com/aprksy/knitknot/pkg/ports/types"
)

// Builder is the fluent query builder
type Builder struct {
        engine  *GraphEngine
        plan    *query.QueryPlan
        nextVar int
}

// Find starts a new query for nodes with given label.
func (ge *GraphEngine) Find(label string) *Builder <span class="cov8" title="17">{
        b := &amp;Builder{
                engine:  ge,
                plan:    &amp;query.QueryPlan{},
                nextVar: 0,
        }
        if ge.defaultSubgraph != "" </span><span class="cov0" title="0">{
                b.plan.Subgraph = ge.defaultSubgraph
        }</span>
        <span class="cov8" title="17">return b.MatchNode("n", label)</span>
}

func (b *Builder) MatchNode(varName, label string) *Builder <span class="cov10" title="30">{
        b.plan.Nodes = append(b.plan.Nodes, &amp;query.PatternNode{
                Var:   varName,
                Label: label,
        })
        if len(b.plan.Outputs) == 0 </span><span class="cov8" title="17">{
                b.plan.Outputs = append(b.plan.Outputs, varName)
        }</span>
        <span class="cov10" title="30">return b</span>
}

func (b *Builder) Where(field, op string, value any) *Builder <span class="cov7" title="13">{
        b.plan.Filters = append(b.plan.Filters, query.Filter{
                Field: field,
                Op:    op,
                Value: value,
        })
        return b
}</span>

func (b *Builder) Limit(n int) *Builder <span class="cov1" title="1">{
        b.plan.LimitVal = &amp;n
        return b
}</span>

func (b *Builder) Has(rel, value string) *Builder <span class="cov7" title="13">{
        v := b.freshVar()

        // Look up verb semantics
        verb, ok := b.engine.verbs.Lookup(rel)
        if !ok </span><span class="cov2" title="2">{
                verb = types.Verb{
                        TargetLabel: "Entity",
                        MatchOn:     types.DefaultMatchProperty,
                }
        }</span>

        <span class="cov7" title="13">targetLabel := verb.TargetLabel
        if targetLabel == "" </span><span class="cov0" title="0">{
                targetLabel = "Entity"
        }</span>

        <span class="cov7" title="13">propKey := verb.MatchOn
        if propKey == "" </span><span class="cov1" title="1">{
                propKey = types.DefaultMatchProperty
        }</span>

        <span class="cov7" title="13">b.MatchNode(v, targetLabel)
        b.RelatedTo(v, rel, "n")
        b.Where(v+"."+propKey, "=", value)

        return b</span>
}

func (b *Builder) RelatedTo(targetVar, edgeKind, sourceVar string) *Builder <span class="cov7" title="13">{
        b.plan.Edges = append(b.plan.Edges, &amp;query.PatternEdge{
                From: sourceVar,
                To:   targetVar,
                Kind: edgeKind,
        })
        return b
}</span>

func (b *Builder) WhereEdge(field, op string, value any) *Builder <span class="cov1" title="1">{
        if len(b.plan.Edges) == 0 </span><span class="cov0" title="0">{
                return b
        }</span>
        <span class="cov1" title="1">edge := b.plan.Edges[len(b.plan.Edges)-1]
        edge.Filters = append(edge.Filters, query.Filter{Field: field, Op: op, Value: value})
        return b</span>
}

func (b *Builder) In(subgraph string) *Builder <span class="cov0" title="0">{
        b.plan.Subgraph = subgraph
        return b
}</span>

func (b *Builder) Exec(ctx context.Context) (query.ResultSet, error) <span class="cov7" title="10">{
        result, err := b.engine.Query(ctx, b.plan)
        return result, err
}</span>

// Only for testing
func (b *Builder) ExportPlanForTest() *query.QueryPlan <span class="cov1" title="1">{
        return b.plan
}</span>

func (b *Builder) freshVar() string <span class="cov7" title="13">{
        id := b.nextVar
        b.nextVar++
        return fmt.Sprintf("v%d", id)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package graph

import (
        "context"

        "github.com/aprksy/knitknot/pkg/ports/query"
        "github.com/aprksy/knitknot/pkg/ports/storage"
        "github.com/aprksy/knitknot/pkg/ports/types"
        q "github.com/aprksy/knitknot/pkg/query"
)

// GraphEngine is the top-level orchestrator that combines storage and query logic.
type GraphEngine struct {
        storage         storage.StorageEngine
        query           query.QueryEngine
        defaultSubgraph string
        verbs           *types.VerbRegistry
}

// NewGraphEngine creates a new engine with default components.
func NewGraphEngine(storage storage.StorageEngine) *GraphEngine <span class="cov7" title="8">{
        return &amp;GraphEngine{
                storage: storage,
                query:   q.NewDefaultQueryEngine(),
                verbs:   types.NewVerbRegistry(),
        }
}</span>

// WithQueryEngine allows replacing the query engine (for testing/plugins).
func (ge *GraphEngine) WithQueryEngine(qe query.QueryEngine) *GraphEngine <span class="cov0" title="0">{
        ge.query = qe
        return ge
}</span>

func (ge *GraphEngine) WithSubgraph(name string) *GraphEngine <span class="cov0" title="0">{
        ge.defaultSubgraph = name
        return ge
}</span>

// AddNode delegates to storage
func (ge *GraphEngine) AddNode(label string, props map[string]any) (string, error) <span class="cov10" title="17">{
        return ge.storage.AddNode(label, props)
}</span>

// AddEdge delegates to storage
func (ge *GraphEngine) AddEdge(from, to, kind string, props map[string]any) error <span class="cov7" title="8">{
        return ge.storage.AddEdge(from, to, kind, props)
}</span>

// GetNode retrieves a node by ID
func (ge *GraphEngine) GetNode(id string) (*types.Node, bool) <span class="cov0" title="0">{
        return ge.storage.GetNode(id)
}</span>

// GetEdge retrieves a edge by ID
func (ge *GraphEngine) GetEdge(id string) (*types.Edge, bool) <span class="cov0" title="0">{
        return ge.storage.GetEdge(id)
}</span>

// Query runs a compiled plan using the query engine
func (ge *GraphEngine) Query(ctx context.Context, plan *query.QueryPlan) (query.ResultSet, error) <span class="cov8" title="10">{
        result, err := ge.query.Execute(ctx, ge.storage, plan)
        return result, err
}</span>

// Storage exposes the underlying engine (useful for exporters, debug)
func (ge *GraphEngine) Storage() storage.StorageEngine <span class="cov0" title="0">{
        return ge.storage
}</span>

// WithVerbs allows replacing or extending the registry
func (ge *GraphEngine) WithVerbs(vr *types.VerbRegistry) *GraphEngine <span class="cov0" title="0">{
        ge.verbs = vr
        return ge
}</span>

// RegisterVerb adds a new relationship semantic
func (ge *GraphEngine) RegisterVerb(name string, def types.Verb) <span class="cov8" title="12">{
        ge.verbs.Register(name, def)
}</span>

// Verbs returns the verb registry (for introspection)
func (ge *GraphEngine) Verbs() *types.VerbRegistry <span class="cov0" title="0">{
        return ge.verbs
}</span>

func (ge *GraphEngine) UpdateNode(id string, props map[string]any) error <span class="cov0" title="0">{
        return ge.storage.UpdateNode(id, props)
}</span>

func (ge *GraphEngine) UpdateEdge(id string, props map[string]any) error <span class="cov0" title="0">{
        return ge.storage.UpdateEdge(id, props)
}</span>

func (ge *GraphEngine) DeleteNode(id string) error <span class="cov0" title="0">{
        return ge.storage.DeleteNode(id)
}</span>

func (ge *GraphEngine) DeleteEdge(from, to, kind string) error <span class="cov0" title="0">{
        return ge.storage.DeleteEdge(from, to, kind)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package query

import (
        "context"
        "strconv"
        "strings"

        "github.com/aprksy/knitknot/pkg/ports/query"
        "github.com/aprksy/knitknot/pkg/ports/storage"
        "github.com/aprksy/knitknot/pkg/ports/types"
)

var _ query.QueryEngine = (*DefaultQueryEngine)(nil)

type DefaultQueryEngine struct{}

func NewDefaultQueryEngine() *DefaultQueryEngine <span class="cov7" title="8">{
        return &amp;DefaultQueryEngine{}
}</span>

func (qe *DefaultQueryEngine) Execute(
        ctx context.Context,
        storage storage.StorageEngine,
        plan *query.QueryPlan,
) (query.ResultSet, error) <span class="cov6" title="6">{
        var results []map[string]*types.Node

        // Start with first node pattern
        if len(plan.Nodes) == 0 </span><span class="cov0" title="0">{
                return &amp;ResultSet{items: results}, nil
        }</span>

        <span class="cov6" title="6">first := plan.Nodes[0]
        candidates := filterNodesByLabel(storage.GetAllNodes(), first.Label)

        for _, node := range candidates </span><span class="cov9" title="16">{
                row := map[string]*types.Node{
                        first.Var: node,
                }

                results = append(results, row)
        }</span>

        // Now extend with remaining nodes + edges
        <span class="cov6" title="6">for _, edgePattern := range plan.Edges </span><span class="cov3" title="2">{
                results = qe.expandViaEdge(storage, results, edgePattern, plan.Nodes, plan.Filters)
        }</span>

        // Apply final filters (some may involve multiple vars)
        <span class="cov6" title="6">filtered := qe.applyAllFilters(results, plan.Filters)

        // Apply limit
        if plan.LimitVal != nil &amp;&amp; len(filtered) &gt; *plan.LimitVal </span><span class="cov0" title="0">{
                filtered = filtered[:*plan.LimitVal]
        }</span>

        <span class="cov6" title="6">return NewResultSet(filtered), nil</span>
}

func (qe *DefaultQueryEngine) matchFilters(row map[string]*types.Node, filters []query.Filter) bool <span class="cov8" title="10">{
        for _, f := range filters </span><span class="cov8" title="10">{
                // Extract var name: e.g., "n.age" → var="n", prop="age"
                parts := strings.SplitN(f.Field, ".", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="10">varName, prop := parts[0], parts[1]

                node, ok := row[varName]
                if !ok </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov8" title="10">val, ok := node.Props[prop]
                if !ok </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov8" title="10">if !compare(val, f.Op, f.Value) </span><span class="cov5" title="4">{
                        return false
                }</span>
        }
        <span class="cov6" title="6">return true</span>
}

func (qe *DefaultQueryEngine) applyAllFilters(rows []map[string]*types.Node, filters []query.Filter) []map[string]*types.Node <span class="cov6" title="6">{
        var result []map[string]*types.Node
        for _, row := range rows </span><span class="cov8" title="10">{
                if qe.matchFilters(row, filters) </span><span class="cov6" title="6">{
                        result = append(result, row)
                }</span>
        }

        <span class="cov6" title="6">return result</span>
}

func (qe *DefaultQueryEngine) findLabelForVar(varName string, nodes []*query.PatternNode) string <span class="cov3" title="2">{
        for _, n := range nodes </span><span class="cov5" title="4">{
                if n.Var == varName </span><span class="cov3" title="2">{
                        return n.Label
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func (qe *DefaultQueryEngine) expandViaEdge(
        storage storage.StorageEngine,
        rows []map[string]*types.Node,
        edgePattern *query.PatternEdge,
        allNodes []*query.PatternNode,
        filters []query.Filter,
) []map[string]*types.Node <span class="cov3" title="2">{
        var expanded []map[string]*types.Node

        fromVar := edgePattern.From
        toVar := edgePattern.To
        kind := edgePattern.Kind

        for _, row := range rows </span><span class="cov7" title="8">{
                fromNode, ok := row[fromVar]
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Get ALL outgoing edges of this kind
                <span class="cov7" title="8">for _, e := range storage.GetEdgesFrom(fromNode.ID) </span><span class="cov5" title="4">{
                        if e.Kind != kind </span><span class="cov1" title="1">{
                                continue</span>
                        }

                        // Check edge filters BEFORE accepting
                        <span class="cov4" title="3">if !qe.matchEdgeFilters(e, edgePattern.Filters) </span><span class="cov1" title="1">{
                                continue</span>
                        }

                        <span class="cov3" title="2">toNode, ok := storage.GetNode(e.To)
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov3" title="2">expectedLabel := qe.findLabelForVar(toVar, allNodes)
                        if expectedLabel != "" &amp;&amp; toNode.Label != expectedLabel </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov3" title="2">newRow := copyMap(row)
                        // newRow := map[string]*types.Node{}
                        newRow[toVar] = toNode

                        // Node/prop filters applied later
                        expanded = append(expanded, newRow)</span>
                }
        }

        <span class="cov3" title="2">return expanded</span>
}

func (qe *DefaultQueryEngine) matchEdgeFilters(edge *types.Edge, filters []query.Filter) bool <span class="cov4" title="3">{
        for _, f := range filters </span><span class="cov3" title="2">{
                val, ok := edge.Props[f.Field]
                if !ok </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov3" title="2">if !compare(val, f.Op, f.Value) </span><span class="cov1" title="1">{
                        return false
                }</span>
        }
        <span class="cov3" title="2">return true</span>
}

func copyMap(m map[string]*types.Node) map[string]*types.Node <span class="cov7" title="8">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov7" title="8">cp := make(map[string]*types.Node, len(m))
        for k, v := range m </span><span class="cov8" title="10">{
                cp[k] = v
        }</span>
        <span class="cov7" title="8">return cp</span>
}

func filterNodesByLabel(nodes []*types.Node, label string) []*types.Node <span class="cov6" title="6">{
        var filtered []*types.Node
        for _, n := range nodes </span><span class="cov10" title="19">{
                if n.Label == label </span><span class="cov9" title="16">{
                        filtered = append(filtered, n)
                }</span>
        }
        <span class="cov6" title="6">return filtered</span>
}

func compare(a any, op string, b any) bool <span class="cov8" title="12">{
        switch op </span>{
        case "=":<span class="cov5" title="4">
                return a == b</span>
        case "!=":<span class="cov3" title="2">
                return a != b</span>
        case "&gt;":<span class="cov5" title="4">
                if ai, ok := toFloat(a); ok </span><span class="cov5" title="4">{
                        if bi, ok := toFloat(b); ok </span><span class="cov5" title="4">{
                                return ai &gt; bi
                        }</span>
                }
        case "&lt;":<span class="cov3" title="2">
                if ai, ok := toFloat(a); ok </span><span class="cov3" title="2">{
                        if bi, ok := toFloat(b); ok </span><span class="cov3" title="2">{
                                return ai &lt; bi
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

func toFloat(v any) (float64, bool) <span class="cov8" title="12">{
        switch n := v.(type) </span>{
        case float64:<span class="cov3" title="2">
                return n, true</span>
        case float32:<span class="cov1" title="1">
                return float64(n), true</span>
        case int:<span class="cov6" title="7">
                return float64(n), true</span>
        case int64:<span class="cov1" title="1">
                return float64(n), true</span>
        case string:<span class="cov1" title="1">
                f, err := strconv.ParseFloat(n, 64)
                return f, err == nil</span>
        default:<span class="cov0" title="0">
                return 0, false</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// internal/storage/inmem/inmem.go
package inmem

import (
        "errors"
        "fmt"
        "math/rand"
        "sync"

        "github.com/aprksy/knitknot/pkg/ports/storage"
        "github.com/aprksy/knitknot/pkg/ports/types"
)

var _ storage.StorageEngine = (*Storage)(nil)

type Storage struct {
        mu    sync.RWMutex
        nodes map[string]*types.Node
        edges map[string]*types.Edge
}

func New() *Storage <span class="cov8" title="19">{
        return &amp;Storage{
                nodes: make(map[string]*types.Node),
                edges: make(map[string]*types.Edge),
        }
}</span>

func (s *Storage) AddNode(label string, props map[string]any) (string, error) <span class="cov9" title="26">{
        id := generateID()
        node := &amp;types.Node{
                ID:        id,
                Label:     label,
                Props:     copyMap(props),
                Subgraphs: map[string]*types.Subgraph{},
        }

        s.mu.Lock()
        defer s.mu.Unlock()

        if _, exists := s.nodes[id]; exists </span><span class="cov0" title="0">{
                return "", errors.New("node already exists")
        }</span>
        <span class="cov9" title="26">s.nodes[id] = node
        return id, nil</span>
}

func (s *Storage) AddToSubgraph(n *types.Node, sgName, sgDesc string) <span class="cov7" title="16">{
        subgraph := &amp;types.Subgraph{
                Name:        sgName,
                Description: sgDesc,
        }
        n.Subgraphs[subgraph.Name] = subgraph
}</span>

func (s *Storage) RemoveFromSubgraph(n *types.Node, sgName string) <span class="cov0" title="0">{
        delete(n.Subgraphs, sgName)
}</span>

func (s *Storage) AddEdge(from, to, kind string, props map[string]any) error <span class="cov6" title="10">{
        s.mu.RLock()
        _, fromOk := s.nodes[from]
        _, toOk := s.nodes[to]
        s.mu.RUnlock()

        if !fromOk </span><span class="cov1" title="1">{
                return errors.New("source node not found")
        }</span>
        <span class="cov6" title="9">if !toOk </span><span class="cov1" title="1">{
                return errors.New("target node not found")
        }</span>

        <span class="cov6" title="8">id := fmt.Sprintf("%s-&gt;%s@%s", from, to, kind)
        edge := &amp;types.Edge{
                ID:        id,
                From:      from,
                To:        to,
                Kind:      kind,
                Props:     copyMap(props),
                Subgraphs: map[string]*types.Subgraph{},
        }

        s.mu.Lock()
        defer s.mu.Unlock()
        s.edges[id] = edge
        return nil</span>
}

func (s *Storage) GetNode(id string) (*types.Node, bool) <span class="cov7" title="14">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        n, ok := s.nodes[id]
        return n, ok
}</span>

func (s *Storage) GetEdge(id string) (*types.Edge, bool) <span class="cov1" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        e, ok := s.edges[id]
        return e, ok
}</span>

func (s *Storage) GetAllNodes() []*types.Node <span class="cov1" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        list := make([]*types.Node, 0, len(s.nodes))
        for _, n := range s.nodes </span><span class="cov2" title="2">{
                list = append(list, n)
        }</span>
        <span class="cov1" title="1">return list</span>
}

func (s *Storage) GetAllEdges() []*types.Edge <span class="cov1" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        list := make([]*types.Edge, 0, len(s.edges))
        for _, e := range s.edges </span><span class="cov1" title="1">{
                list = append(list, e)
        }</span>
        <span class="cov1" title="1">return list</span>
}

func (s *Storage) GetEdgesFrom(from string) []*types.Edge <span class="cov4" title="4">{
        return s.findEdges(func(e *types.Edge) bool </span><span class="cov3" title="3">{ return e.From == from }</span>)
}

func (s *Storage) GetEdgesTo(to string) []*types.Edge <span class="cov0" title="0">{
        return s.findEdges(func(e *types.Edge) bool </span><span class="cov0" title="0">{ return e.To == to }</span>)
}

func (s *Storage) GetEdgesByKind(kind string) []*types.Edge <span class="cov0" title="0">{
        return s.findEdges(func(e *types.Edge) bool </span><span class="cov0" title="0">{ return e.Kind == kind }</span>)
}

func (s *Storage) UpdateNode(id string, props map[string]any) error <span class="cov3" title="3">{
        s.mu.Lock()
        defer s.mu.Unlock()

        node, ok := s.nodes[id]
        if !ok </span><span class="cov1" title="1">{
                return fmt.Errorf("node not found")
        }</span>

        <span class="cov2" title="2">node.Props = copyMap(props)
        return nil</span>
}

func (s *Storage) UpdateEdge(id string, props map[string]any) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        edge, ok := s.edges[id]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("node not found")
        }</span>

        <span class="cov0" title="0">edge.Props = copyMap(props)
        return nil</span>
}

func (s *Storage) findEdges(match func(*types.Edge) bool) []*types.Edge <span class="cov4" title="4">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        var result []*types.Edge
        for _, e := range s.edges </span><span class="cov3" title="3">{
                if match(e) </span><span class="cov3" title="3">{
                        result = append(result, e)
                }</span>
        }
        <span class="cov4" title="4">return result</span>
}

func (s *Storage) GetNodesIn(subgraph string) []*types.Node <span class="cov3" title="3">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        var result []*types.Node
        for _, n := range s.nodes </span><span class="cov5" title="6">{
                if _, exists := n.Subgraphs[subgraph]; exists </span><span class="cov4" title="4">{
                        result = append(result, n)
                }</span>
        }
        <span class="cov3" title="3">return result</span>
}

func (s *Storage) GetEdgesIn(subgraph string) []*types.Edge <span class="cov1" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        var result []*types.Edge
        for _, e := range s.edges </span><span class="cov1" title="1">{
                // Edge belongs to subgraph if both ends do AND edge hasn't been removed
                fromNode, ok1 := s.nodes[e.From]
                toNode, ok2 := s.nodes[e.To]
                if !ok1 || !ok2 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov1" title="1">sgInstance, fromNodeExists := fromNode.Subgraphs[subgraph]
                _, toNodeExists := toNode.Subgraphs[subgraph]

                if fromNodeExists &amp;&amp; toNodeExists </span><span class="cov1" title="1">{
                        // Optionally: ensure edge itself includes subgraph
                        if _, exists := e.Subgraphs[subgraph]; exists </span><span class="cov0" title="0">{
                                result = append(result, e)
                        }</span> else<span class="cov1" title="1"> {
                                // Auto-inherit
                                cp := *e
                                cp.Subgraphs[subgraph] = sgInstance
                                result = append(result, &amp;cp)
                        }</span>
                }
        }
        <span class="cov1" title="1">return result</span>
}

func (s *Storage) DeleteNode(id string) error <span class="cov3" title="3">{
        s.mu.Lock()
        defer s.mu.Unlock()
        if _, ok := s.nodes[id]; !ok </span><span class="cov1" title="1">{
                return fmt.Errorf("node not found")
        }</span>
        <span class="cov2" title="2">delete(s.nodes, id)
        // Optionally remove edges too
        return nil</span>
}

func (s *Storage) DeleteEdge(from, to, kind string) error <span class="cov3" title="3">{
        s.mu.Lock()
        defer s.mu.Unlock()
        id := fmt.Sprintf("%s-&gt;%s@%s", from, to, kind)
        if _, ok := s.edges[id]; !ok </span><span class="cov1" title="1">{
                return fmt.Errorf("edge not found")
        }</span>
        <span class="cov2" title="2">delete(s.edges, id)
        return nil</span>
}

// Helpers
func copyMap(m map[string]any) map[string]any <span class="cov10" title="36">{
        if m == nil </span><span class="cov8" title="17">{
                return nil
        }</span>
        <span class="cov8" title="19">cp := make(map[string]any, len(m))
        for k, v := range m </span><span class="cov9" title="25">{
                cp[k] = v
        }</span>
        <span class="cov8" title="19">return cp</span>
}

func generateID() string <span class="cov9" title="26">{
        // Reuse your ID generator
        return fmt.Sprintf("n%d", rand.Intn(1000000)) // simplify for now
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package inmem

import (
        "encoding/gob"
        "fmt"
        "os"
        "path/filepath"

        "github.com/aprksy/knitknot/pkg/graph"
        "github.com/aprksy/knitknot/pkg/ports/types"
        "github.com/aprksy/knitknot/pkg/storage/file"
)

// Save writes the current graph state to disk
func (s *Storage) Save(filename string, engine *graph.GraphEngine) error <span class="cov6" title="3">{
        // Ensure dir exists
        _ = os.MkdirAll(filepath.Dir(filename), 0755)

        f, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="3">defer func() </span><span class="cov6" title="3">{
                if closeErr := f.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        if err == nil </span><span class="cov0" title="0">{
                                err = closeErr
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("Error closing file: %v (original error: %v)\n", closeErr, err)
                        }</span>
                }
        }()

        <span class="cov6" title="3">saved := &amp;file.SavedGraph{
                Version: file.CurrentVersion,
                Nodes:   make(map[string]*types.Node),
                Edges:   make(map[string]*types.Edge),
                Verbs:   make(map[string]types.Verb),
        }

        s.mu.RLock()
        defer s.mu.RUnlock()

        // Copy nodes and edges
        for id, n := range s.nodes </span><span class="cov10" title="6">{
                saved.Nodes[id] = n
        }</span>
        <span class="cov6" title="3">for id, e := range s.edges </span><span class="cov6" title="3">{
                saved.Edges[id] = e
        }</span>

        <span class="cov6" title="3">saved.Verbs = engine.Verbs().All()

        encoder := gob.NewEncoder(f)
        return encoder.Encode(saved)</span>
}

// Load populates the storage from a file
func (s *Storage) Load(filename string, engine *graph.GraphEngine) error <span class="cov6" title="3">{
        f, err := os.Open(filename)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov4" title="2">defer func() </span><span class="cov4" title="2">{
                if closeErr := f.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        if err == nil </span><span class="cov0" title="0">{
                                err = closeErr
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("Error closing file: %v (original error: %v)\n", closeErr, err)
                        }</span>
                }
        }()

        <span class="cov4" title="2">var saved file.SavedGraph
        decoder := gob.NewDecoder(f)
        if err := decoder.Decode(&amp;saved); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="2">if saved.Version != file.CurrentVersion </span><span class="cov0" title="0">{
                return fmt.Errorf("unsupported version: %s (expected %s)", saved.Version, file.CurrentVersion)
        }</span>

        <span class="cov4" title="2">s.mu.Lock()
        defer s.mu.Unlock()

        // Clear existing
        s.nodes = make(map[string]*types.Node)
        s.edges = make(map[string]*types.Edge)

        // Restore
        for id, n := range saved.Nodes </span><span class="cov7" title="4">{
                s.nodes[id] = n
        }</span>
        <span class="cov4" title="2">for id, e := range saved.Edges </span><span class="cov4" title="2">{
                s.edges[id] = e
        }</span>

        // After restoring nodes/edges
        <span class="cov4" title="2">for name, verb := range saved.Verbs </span><span class="cov1" title="1">{
                engine.RegisterVerb(name, verb) // assuming engine is passed in
        }</span>

        <span class="cov4" title="2">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
